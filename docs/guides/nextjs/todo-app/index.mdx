---
title: "Tutorial: To-do app"
---

import {
  HomepageCard as Card,
  HomepageSection as Section,
} from "../../../../src/components/HomepageComponents";
import TerminalWindow from "@site/src/components/TerminalWindow/index";
import CodeBlock from "@theme/CodeBlock";
import createNextAppOutput from "!!raw-loader!./_createNextAppOutput";
import runDevOutput from "!!raw-loader!./_runDevOutput";
import loginOutput from "!!raw-loader!./_loginOutput";
import tigrisCreateAppOutput from "!!raw-loader!./_tigrisCreateAppOutput";
import Installation from "../../../includes/_install_cloud_login.mdx";

# Fullstack App with Next.js, Tigris and TypeScript: To-do app

This is the first of a series of articles where we will demonstrate how easy it is to build fullstack
apps using [Tigris](https://docs.tigrisdata.com/) and [Next.js][nextjs-url]. This tutorial series is
a comprehensive way to getting an overview of the primary APIs available in Tigris.

The article will be focused on Tigris and Next.js and may skip over few things like styling etc. which
will be pre-generated in the template used for this tutorial.

## What will we build?

This tutorial will focus on building a To-do list app using Next.js and Tigris, where users can

- add to-do items to the list
- update to-do items as completed
- delete to-do items
- search for to-do items in the list

[Here is a link](https://tigris-nextjs-starter-kit.vercel.app/) to working example of the To-do application
that you will build. The source code is available on [GitHub repo][tigris-todo-repo-url] if you feel
like exploring on your own, else follow along the tutorial.

## Prerequisites

<Installation />

## Generating the project

Let's get started, open the terminal and run following command:

```shell
npx create-next-app@latest --example https://github.com/tigrisdata/tigris-vercel-starter/tree/main-scaffold
```

This is a simple command to quickly start building a new Next.js application based off a template.
It may ask you a project name to download the project resources. We chose `starter-todo-app` as our
project name.

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{createNextAppOutput}</CodeBlock>
</TerminalWindow>
```

:::danger
Do not run any of `npm run dev`, `npm run build` or `npm start` commands yet. This project template
has some missing parts which you will complete in this tutorial and then after these few steps, you
will be able to to build, run and deploy your To-do list application.
:::

## Project structure

`cd` into the our project directory

```shell
cd starter-todo-app # or the project name you provided in previous step
```

Here are some important components in our project. We will briefly talk about a few files/directories

```text
starter-todo-app
â”œâ”€â”€ package.json
â”œâ”€â”€ scripts
â”‚   â””â”€â”€ setup.ts
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ tigris.ts
â”œâ”€â”€ models
â”‚   â””â”€â”€ tigris
â”‚       â””â”€â”€ todoStarterApp
â”‚           â””â”€â”€ todoItems.ts
â””â”€â”€ pages
    â”œâ”€â”€ index.tsx
    â””â”€â”€ api
        â”œâ”€â”€ item
        â”‚   â”œâ”€â”€ [id].ts
        â””â”€â”€ items
            â”œâ”€â”€ index.ts
            â””â”€â”€ search.ts
```

- `package.json` - Configuration for our Node project
- `scripts/setup.ts` - Script that will bootstrap databases and collections automatically at build time
- `lib/tigris.ts` - Client to interact with Tigris. The client is responsible to make all requests
  to Tigris
- `models/tigris/` - This directory has our Tigris schema definitions and models
- `pages/` - Directory used by Next.js to create routes. This is where all our application code lives
- `pages/api/` - All API endpoints for Next.js application are defined in this directory

## Update the application

We will be adding code incrementally to our application. First step would be to define the data model
for our application.

### Add the Tigris cloud credentials

Our application requires credentials to be able to use Tigris. Let's generate the credentials and
add them to the environment file.

#### Generating application credentials

```shell
tigris create application starter-todo-app "Starter todo application"
```

This command will create the credentials and print it on the terminal screen

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{tigrisCreateAppOutput}</CodeBlock>
</TerminalWindow>
```

We will use the `id` and `secret` from the output and add them as `TIGRIS_CLIENT_ID` and `TIGRIS_CLIENT_SECRET`
respectively in the file `.env.development.local`. Now, let's create the environment file
`.env.development.local` and add the application credentials generated above to it

```dotenv title=.env.development.local
TIGRIS_CLIENT_ID=client_id_here
TIGRIS_CLIENT_SECRET=client_secret_here
```

### Defining the data model{#data-model}

Tigris stores data records as documents. Documents are analogous to JSON objects grouped together in
a [Collection](/overview/databases). Our to-do list app has a single collection `todoItems` that
stores to-do items as documents.

This to-do app follows a convention of having models and schemas in `models/tigris` directory. Within
the directory we have `todoStarterApp` directory that will be our database name and the file
`todoItems.ts` describes the schema for collection named `todoItems`.

Let's add following highlighted code to `models/tigris/todoStarterApp/todoItems.ts`:

```ts title=models/tigris/todoStarterApp/todoItems.ts
import {
  TigrisCollectionType,
  TigrisDataTypes,
  TigrisSchema,
} from "@tigrisdata/core/dist/types";

export const COLLECTION_NAME = "todoItems";

// highlight-start
export interface TodoItem extends TigrisCollectionType {
  id: number;
  text: string;
  completed: boolean;
}

export const TodoItemSchema: TigrisSchema<TodoItem> = {
  id: {
    type: TigrisDataTypes.INT32,
    primary_key: { order: 1, autoGenerate: true },
  },
  text: { type: TigrisDataTypes.STRING },
  completed: { type: TigrisDataTypes.BOOLEAN },
};
// highlight-end
```

We defined a data model named `TodoItem` to use in our application and created `TodoItemSchema` as a
`TigrisSchema` for the data model. In the next section we show how these data models are used to
automatically define databases and collections, and how the schemas are kept in sync with the models.

### Setting up automatic schema management

Tigris makes it really easy to [automate schema management](/typescript/documents/schema-bootstrap)
by using the models defined in your project.
In this section we will setup the code that is responsible for automatically managing schemas
corresponding to the [data model defined above](#data-model).
Let's see how this works by adding following code to
`scripts/setup.ts` file:

```ts title=scripts/setup.ts
import { Tigris } from "@tigrisdata/core";
import { loadEnvConfig } from "@next/env";

// Run the config loader only when not executing within next runtime
if (process.env.NODE_ENV === undefined) {
  if (process.env.APP_ENV === "development") {
    loadEnvConfig(process.cwd(), true);
  } else if (process.env.APP_ENV === "production") {
    loadEnvConfig(process.cwd());
  }
}

async function main() {
  // highlight-start
  // setup client and register schemas
  const tigrisClient = new Tigris();
  await tigrisClient.registerSchemas("models/tigris");
  // highlight-end
}

main();
```

The main thing to see here is the `registerSchemas()` method that accepts a path which is then scanned to
derive databases and collections that need to be created. We registered `models/tigris` directory with
Tigris client that includes a `todoStarterApp` directory and `todoItems.ts` file with `TodoItemSchema`
defined.

A database named `todoStarterApp` (derived from directory name) and a collection named `todoItems`
(derived from filename) will be created conforming to `TodoItemSchema`. If the collection
already exists, it will apply schema changes, if any, to that collection.

See, how you don't have to explicitly "create a database and collection" or "make changes to
collection schemas"; everything is handled by `registerSchemas()` for you.

Let's further automate this process by always executing the script at build time. Open
`package.json` in editor and add following highlighted scripts:

```json title=package.json
  "scripts": {
    // highlight-next-line
    "predev": "APP_ENV=development npm run setup",
    "dev": "next dev",
    "build": "next build",
    // highlight-next-line
    "postbuild": "APP_ENV=production npm run setup",
    "start": "next start",
    "clean": "rm -rf node_modules .next",
    // highlight-next-line
    "setup": "npx ts-node scripts/setup.ts"
  }
```

We added a `setup` command to run `scripts/setup.ts` and then added a `predev` hook to setup
schemas right before `dev` command is executed. Additionally, we added a `postbuild` hook to
setup schemas in production environment right after `build`. Now, all your databases and
collections will be in sync with model definitions in code.

:::tip No more schema management
You don't have to worry about applying schema changes anymore, managing schema is now a part of your
development workflow. Read more about this automated schema management [here](/typescript/documents/schema-bootstrap).
:::

### API endpoints to access data in Tigris

Let's write some REST endpoints to execute CRUD operations against `todoItems` collection. These
endpoints will be used by the client component of to-do app to perform data operations in Tigris.
Next.js convention is to define API endpoints inside `pages/api/` directory. Any file or folder
inside `pages/api/` is mapped to `/api/*` route.

#### âŒ² GET `/api/items` to fetch all to-do items

For our convenience, `pages/api/items/index.ts` is included in our template that maps to `/api/items`
API route for our Next.js application. Let's implement `handleGet()` function in this file that will
fetch the available to-do items from Tigris collection.

```ts title=pages/api/items/index.ts
async function handleGet(req: NextApiRequest, res: NextApiResponse<Response>) {
  // highlight-start
  try {
    const itemsCollection = tigrisDb.getCollection<TodoItem>(COLLECTION_NAME);
    const cursor = itemsCollection.findMany();
    const items = await cursor.toArray();
    res.status(200).json({ result: items });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
  // highlight-end
}
```

Here we used a simple `findMany()` construct to read documents from a Tigris collection and returned
them as json.

#### âŒ² POST `/api/items` to add to-do item

Now, let's implement a `POST` method in `pages/api/items/index.ts` that will insert an item to
this collection.

```ts title=pages/api/items/index.ts
async function handlePost(req: NextApiRequest, res: NextApiResponse<Response>) {
  // highlight-start
  try {
    const item = JSON.parse(req.body) as TodoItem;
    const itemsCollection = tigrisDb.getCollection<TodoItem>(COLLECTION_NAME);
    const inserted = await itemsCollection.insertOne(item);
    res.status(200).json({ result: [inserted] });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
  // highlight-end
}
```

This enables user to insert a new item to the to-do list.

#### âŒ² PUT `/api/item/[id]` to mark a to-do item as completed

So far, we have got routes to insert a new item and get all items from Tigris collection. For
a user to be able to mark item as completed, we will need a route that updates the to-do item in
collection. We will add `PUT` method in `api/item/[id]` endpoint, where `id` is the unique
identifier for the item that is being updated.

Next.js supports [dynamic routes](https://nextjs.org/docs/api-routes/dynamic-api-routes) by naming
file as a **url slug**. In this case, the file `pages/api/item/[id].ts` can map to `/api/item/1`,
`/api/item/abc` etc. Let's implement `handlePut()` method in this file.

```ts title=pages/api/item/[id].ts
async function handlePut(req: NextApiRequest, res: NextApiResponse<Data>) {
  // highlight-start
  try {
    const item = JSON.parse(req.body) as TodoItem;
    const itemsCollection = tigrisDb.getCollection<TodoItem>(COLLECTION_NAME);
    const updated = await itemsCollection.insertOrReplaceOne(item);
    res.status(200).json({ result: updated });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
  // highlight-end
}
```

We are leveraging `insertOrReplaceOne()` function offered by the Tigris SDK that will replace the
item in entirety with the new one. We can as well use the [`updateOne()`](/typescript/documents/update)
function here to update individual fields instead of replacing whole document.

#### âŒ² DELETE `/api/item/[id]` to remove item from list

Similar to PUT method above, we will now add a `DELETE` method to our `/api/item/[id]` endpoint to
remove items from `todoItems` collection in the same `pages/api/item/[id].ts` file. By now, you know
the drill, our template only needs highlighted code ðŸ˜Š

```ts title=pages/api/item/[id].ts
async function handleDelete(
  req: NextApiRequest,
  res: NextApiResponse<Data>,
  itemId: number
) {
  // highlight-start
  try {
    const itemsCollection = tigrisDb.getCollection<TodoItem>(COLLECTION_NAME);
    const status = (await itemsCollection.deleteOne({ id: itemId })).status;
    if (status === "deleted") {
      res.status(200).json({});
    } else {
      res.status(500).json({ error: `Failed to delete ${itemId}` });
    }
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
  // highlight-end
}
```

The `deleteOne()` function accepts a filter and limits the deletion to only one document in the collection
matching the given filter. The operation has no effect if there is no document matching the specified filter.

#### âŒ² GET `/api/items/search` to find items matching the given query

Search endpoint will allow users to be able to find items in the list. Let's add this endpoint that
accepts a query parameter and responds with matching results. GET `/api/items/search?q="input query"`
will be added in `pages/api/items/search.ts` file.

```ts title=pages/api/items/search.ts
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  // highlight-start
  const query = req.query["q"];
  if (query === undefined) {
    res.status(400).json({ error: "No search query found in request" });
    return;
  }
  try {
    const itemsCollection = tigrisDb.getCollection<TodoItem>(COLLECTION_NAME);
    const searchRequest: SearchRequest<TodoItem> = { q: query as string };
    const searchResult = await itemsCollection.search(searchRequest);
    const items = new Array<TodoItem>();
    for (const hit of searchResult.hits) {
      items.push(hit.document);
    }
    res.status(200).json({ result: items });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
  // highlight-end
}
```

:::tip Built-in search
Tigris makes it really easy to implement [search](/typescript/documents/search) within your applications
by providing an embedded search engine that makes all your data instantly searchable.
:::

## Explore user interface

All the browser rendered pages are to be defined in `pages/` directory in Next.js. In this section,
we will only explore some of the included front end code of our application.

`pages/index.tsx` defines the React component that is rendered on the browser. It uses the API
endpoints we created in the previous section. For example, here is the `fetchListItems()` function
that renders the list by loading to-do items from `/api/items` endpoint:

```ts title=pages/index.tsx
const fetchListItems = () => {
  setIsLoading(true);
  setIsError(false);

  fetch("/api/items")
    .then((response) => response.json())
    .then((data) => {
      setIsLoading(false);
      if (data.result) {
        setViewMode("list");
        setTodoList(data.result);
      } else {
        setIsError(true);
      }
    })
    .catch(() => {
      setIsLoading(false);
      setIsError(true);
    });
};
```

Similarly, the `addTodoItem()`, to add a to-do list item, simply makes a POST request to `/api/items`

```ts title=pages/index.tsx
const addToDoItem = () => {
  if (queryCheckWiggle()) {
    return;
  }
  setIsLoading(true);

  fetch("/api/items", {
    method: "POST",
    body: JSON.stringify({ text: textInput, completed: false }),
  }).then(() => {
    setIsLoading(false);
    setTextInput("");
    fetchListItems();
  });
};
```

Feel free to explore the code or continue along as we put together the final pieces of our application.

## Run the app

Let's reap the rewards. Start the Tigris development environment using `tigris dev start` if not
started already and then Next.js app by executing `npm run dev` in terminal.

You should see following output:

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{runDevOutput}</CodeBlock>
</TerminalWindow>
```

Voila! there you have it. To-do application is accessible on [http://localhost:3000](http://localhost:3000)
on your browser, go ahead and play around.

![Next.js todo app tutorial screenshot](/img/screenshots/nextjs-todo-app-tutorial.jpg)

[You can also login to the Tigris Cloud Console and explore the data there.](https://console.preview.tigrisdata.cloud/explorer/todoStarterApp/todoItems)

## Deploy the application

So far we have built a Next.js application and connected it to Tigris backend. We are now ready to take
the next step and deploy it to production. Next.js and Tigris can be deployed to multiple
platforms and services, let's look at a few available options:

<Section className="two-cols">
  <Card
    title="Deploy to Vercel"
    description="Deployment instructions for Vercel"
    to="/guides/nextjs/deploy-to-vercel"
  />
  <Card
    title="Deploy to Netlify"
    description="Deployment instructions for Netlify"
    to="/guides/nextjs/deploy-to-netlify"
  />
</Section>

> Note: If you would like deployment instructions for a service not on this list, let us know!

## Summary

In this tutorial, you built a to-do list Next.js app that uses Tigris as the backend. You saw all
the powerful functionality that Tigris provides, and how easy it is to use. Now, its time to
[tweet your success][tweet-intent] :smile:

Stay, tuned as we publish more tutorials and reach out to the team to learn what we are building next.

Happy learning!

<!-- MARKDOWN LINKS -->

[nextjs-url]: https://nextjs.org/
[tigris-todo-repo-url]: https://github.com/tigrisdata/tigris-vercel-starter
[tweet-intent]: https://twitter.com/intent/tweet?url=https%3A%2F%2Ftigrisdata.com%2Fnextjs%2F&text=I%20learned%20how%20easy%20it%20is%20to%20build%20%23data%20rich%20applications%20using%20@nextjs%20and%20@TigrisData
